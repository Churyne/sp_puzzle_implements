# SP谜题

## 1. 描述

存在两个整数 `m` 和 `n`，满足 `2 ≤ m ≤ n ≤ 98`。
- S先生知道两数之和 `s = m + n`。
- P先生知道两数之积 `p = m * n`。

对话如下：
1. S: 我知道你不知道 `m` 和 `n`，但我也不知道。
2. P: 现在我知道了。
3. S: 现在我也知道了。

问题：推断 `m` 和 `n` 的值。

## 2. 证明

### 2.1 定义

-   **全集 `Ω`**: 所有满足 `2 ≤ m ≤ n ≤ 98` 的整数对 `(m, n)` 的集合。
    `Ω = {(m, n) ∈ ℤ² | 2 ≤ m ≤ n ≤ 98}`
-   **按和划分 `L_s`**: 将 `Ω` 按和 `s` 进行划分的集合。`L_s[s]` 代表和为 `s` 的所有数对。
-   **按积划分 `L_p`**: 将 `Ω` 按积 `p` 进行划分的集合。`L_p[p]` 代表积为 `p` 的所有数对。
-   **基数 `|S|`**: 集合 `S` 中元素的数量。

### 2.2 推理过程

#### **阶段一: S的第一陈述**

S的陈述：“我知道你（P）不知道 `m` 和 `n`，但我（S）也不知道。”

1.  **"我（S）也不知道"** 意味着S持有的和 `s` 存在多种可能的分解。
    -   数学表达: `|L_s[s]| > 1`

2.  **"我知道你（P）不知道"** 意味着S对 `s` 的所有可能分解 `(m', n')` 进行推演，发现其积 `p' = m' * n'` 均不是唯一的分解。P知道答案的充要条件是 `|L_p[p]| = 1`。因此，S的断言等价于：
    -   数学表达: `∀(m', n') ∈ L_s[s], |L_p[m' * n']| > 1`

**定义集合 `S₁`** 为所有满足上述两个条件的和 `s` 的集合。`s ∈ S₁` 是P进行下一步推理的先验知识。

`S₁ = {s | |L_s[s]| > 1 ∧ (∀(m', n') ∈ L_s[s], |L_p[m' * n']| > 1)}`

#### **阶段二: P的陈述**

P的陈述：“现在我知道了！”

P持有积 `p`。听完S的话，P得知真实的和 `s` 必须在 `S₁` 中。P检查其积 `p` 的所有分解 `(m_i, n_i) ∈ L_p[p]`，并计算对应的和 `s_i = m_i + n_i`。P能确定答案，当且仅当这些和 `s_i` 中，只有一个落在集合 `S₁` 内。

**定义候选集 `Ω₂`** 为所有满足此条件的数对 `(m, n)` 的集合。
`Ω₂ = {(m, n) ∈ Ω | |{(m', n') ∈ L_p[m*n] | m'+n' ∈ S₁}| = 1}`

#### **阶段三: S的第二陈述**

S的陈述：“现在我也知道了！”

S持有和 `s`，并且知道真实的数对一定在 `Ω₂` 中。S能确定答案，当且仅当其和 `s` 在 `Ω₂` 中只对应唯一一个数对。

**定义最终解 `(m_f, n_f)`**。
`(m_f, n_f)` 是集合 `{(m, n) ∈ Ω₂ | |{(m', n') ∈ Ω₂ | m'+n' = m_f+n_f}| = 1}` 中的唯一元素。

## 3. CSharp代码

```csharp
// Ω: 全集a
var a = Enumerable.Range(2, 98)
    .SelectMany(m => Enumerable.Range(m, 100 - m)
        .Select(n => (m, n, s: m + n, p: (long)m * n)));
// L_s, L_p: 查找表s, p
var (s, p) = (a.ToLookup(x => x.s), a.ToLookup(x => x.p));

var t = p // 从L_p开始
    // 1. 初始约束: P不确定 -> |L_p[p]| > 1
    .Where(g => g.Count() > 1) 
    // 2. 筛选p的分解，使其和s必须在S₁中。
    //    内部的Where子句精确定义了 s ∈ S₁
    .Select(g => g.Where(x => s[x.s].Count() > 1 && s[x.s].All(y => p[y.p].Count() > 1)))
    // 3. 应用P的陈述，得到只含一个有效分解的集合，构造了Ω₂的子集
    .Where(v => v.Count() == 1)
    // 4. 展开，得到候选集 Ω₂
    .SelectMany(v => v)
    // 5. 按和s分组，为S的最终陈述做准备
    .GroupBy(x => x.s)
    // 6. 应用S的第二陈述: 和s在Ω₂中是唯一的
    .Single(g => g.Count() == 1)
    // 7. 提取唯一解
    .Single();
```

## 4. 结论

执行代码得出的唯一解为：
- `m = 4`, `n = 13`
- `s = 17`, `p = 52`